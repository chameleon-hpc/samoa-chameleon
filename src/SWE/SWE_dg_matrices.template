#include "Compilation_control.f90"

#if defined(_SWE_DG)
#define _REF_TRIANGLE_SIZE_INV  (2.0q0 * real(_SWE_PATCH_ORDER_SQUARE,kind=kind(1.0q0)))
MODULE SWE_dg_matrices
	implicit none
	
#       if defined(_SINGLE_PRECISION)
            integer, PARAMETER :: GRID_SR = kind(1.0e0)
#       elif defined(_DOUBLE_PRECISION)
            integer, PARAMETER :: GRID_SR = kind(1.0d0)
#       elif defined(_QUAD_PRECISION)
            integer, PARAMETER :: GRID_SR = kind(1.0q0)
#       else
#           error "No floating point precision is chosen!"
#       endif

! #if defined (_SWE_DG_EXTRAPOLATE_BND)
! #define _SWE_DG_BND_INTEGRATION_POINTS 0
! #else
! #define _SWE_DG_BND_INTEGRATION_POINTS _SWE_DG_ORDER+1
! #endif
! #define 

!Time matrices
#include "dg_matrices/t_m_1_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/t_a_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/t_k_t_10_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/t_k_t_11_inv_SWE_DG_ORDER_TAG.incl"
    	    
!Space matrices
#include "dg_matrices/s_m_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_m_inv_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_k_x_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_k_y_SWE_DG_ORDER_TAG.incl"

!Boundary matrices
#include "dg_matrices/s_b_1_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_b_2_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_b_3_SWE_DG_ORDER_TAG.incl"

#include "dg_matrices/s_b_1_l_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_b_2_m_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/s_b_3_r_SWE_DG_ORDER_TAG.incl"

!FV projection
#include "dg_matrices/phi_l_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/phi_m_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/phi_r_SWE_DG_ORDER_TAG.incl"

!#include "dg_matrices/phi_8_p1.incl"
!#include "dg_matrices/phi_8_p2.incl"

#include "dg_matrices/phi_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/mue_inv_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/mue_inv_slope_SWE_DG_ORDER_TAG.incl"

!Basis nodes and weights
#include "dg_matrices/nodes_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/weights_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/mirrored_coords_SWE_DG_ORDER_TAG.incl"

!Basis derivatives
#include "dg_matrices/basis_der_x_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/basis_der_y_SWE_DG_ORDER_TAG.incl"
	    
!Refinement matrices
#include "dg_matrices/ref1_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/ref2_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/coarsen1_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/coarsen2_SWE_DG_ORDER_TAG.incl"

!gll nodes
#include "dg_matrices/gll_nodes_SWE_DG_ORDER_TAG.incl"
#include "dg_matrices/gll_weights_SWE_DG_ORDER_TAG.incl"

#include "dg_matrices/jacobian.incl"
#include "dg_matrices/jacobian_inv.incl"

real(kind=GRID_SR), Parameter :: s_m_inv_s_k_x_t   (_SWE_DG_DOFS,_SWE_DG_DOFS)     = matmul(s_m_inv,transpose(s_k_x))
real(kind=GRID_SR), Parameter :: s_m_inv_s_k_y_t   (_SWE_DG_DOFS,_SWE_DG_DOFS)     = matmul(s_m_inv,transpose(s_k_y))
real(kind=GRID_SR), Parameter :: t_k_t_11_inv_t_m_1(_SWE_DG_ORDER,_SWE_DG_ORDER+1) = matmul(t_k_t_11_inv,t_m_1)
real(kind=GRID_SR), Parameter :: s_k_x_s_b_3_s_b_2 (_SWE_DG_DOFS,_SWE_DG_DOFS)     = s_k_x + s_b_3 - s_b_2
real(kind=GRID_SR), Parameter :: s_k_y_s_b_1_s_b_2 (_SWE_DG_DOFS,_SWE_DG_DOFS)     = s_k_y + s_b_1 - s_b_2
real(kind=GRID_SR), Parameter :: t_k_t_11_inv_x_t_k_t_10(_SWE_DG_ORDER,1)          = matmul(t_k_t_11_inv,t_k_t_10)

real(kind=GRID_SR), Parameter :: s_k_x_t (_SWE_DG_DOFS,_SWE_DG_DOFS)     = transpose(-s_k_x)
real(kind=GRID_SR), Parameter :: s_k_y_t (_SWE_DG_DOFS,_SWE_DG_DOFS)     = transpose(-s_k_y)

real(kind=GRID_SR),Parameter :: s_m_inv_ref1(_SWE_DG_DOFS,_SWE_DG_DOFS)  = matmul(s_m_inv,ref1)
real(kind=GRID_SR),Parameter :: s_m_inv_ref2(_SWE_DG_DOFS,_SWE_DG_DOFS)  = matmul(s_m_inv,ref2)
real(kind=GRID_SR),Parameter :: s_m_inv_coarsen1(_SWE_DG_DOFS,_SWE_DG_DOFS) =&
			     matmul(s_m_inv,coarsen1)
real(kind=GRID_SR),Parameter :: s_m_inv_coarsen2(_SWE_DG_DOFS,_SWE_DG_DOFS) =&
			     matmul(s_m_inv,coarsen2)

real(kind=GRID_SR) :: phi_hat(_SWE_PATCH_ORDER_SQUARE,_SWE_DG_DOFS)
real(kind=GRID_SR) :: mue_inv_hat(_SWE_DG_DOFS,_SWE_PATCH_ORDER_SQUARE)

real(kind=GRID_SR) :: basis_der_x_hat(_SWE_DG_DOFS,_SWE_DG_DOFS)
real(kind=GRID_SR) :: basis_der_y_hat(_SWE_DG_DOFS,_SWE_DG_DOFS)
real(kind=GRID_SR) :: t_k_t_11_inv_x_t_k_t_10_hat(_SWE_DG_ORDER,1)

!real(kind=GRID_SR)    :: project_DG(3,_SWE_DG_ORDER+1,_SWE_DG_DOFS)
integer(kind=GRID_SR) :: idx_project_DG(3,_SWE_DG_ORDER+1)
integer(kind=GRID_SR) :: idx_project_FV(3,_SWE_PATCH_ORDER)
!     real(kind=GRID_SR) :: project_FV(3,_SWE_PATCH_ORDER,_SWE_PATCH_ORDER_SQUARE)

real(KIND=GRID_SR),Parameter :: phi_b(3,_SWE_PATCH_ORDER,_SWE_DG_DOFS) = (/ phi_r , phi_m , phi_l /)			
real(kind=GRID_SR) :: norm_to_edge_type(8,-2:2,-2:2)      
contains

!basis functions
#include "dg_matrices/basis_SWE_DG_ORDER_TAG.incl"

subroutine init_matrices()
  call init_phi_hat()
  call init_mue_inv_hat()
  call init_basis_der_x_hat()
  call init_basis_der_y_hat()
  call init_t_k_t_11_inv_x_t_k_t_10_hat()
  call init_projection()
	call init_norm_to_edge_type()
end subroutine
	
subroutine init_phi_hat()
	real(kind=GRID_SR),dimension(_SWE_PATCH_ORDER_SQUARE,_SWE_DG_DOFS) :: R
	real(kind=GRID_SR),dimension(_SWE_PATCH_ORDER_SQUARE) :: v
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS)            :: vn
	real(kind=GRID_SR),dimension(_SWE_PATCH_ORDER_SQUARE) :: vm	                   
	integer :: i
                   
	R = 0.0_GRID_SR
	vn = 1.0_GRID_SR
	vm = 1.0_GRID_SR
	v = vm - matmul(phi,vn)
	
	do i = 1,_SWE_PATCH_ORDER_SQUARE
	   R(i,1) = v(i)
	end do
	
	phi_hat = phi+R
end subroutine

subroutine init_mue_inv_hat()
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS,_SWE_PATCH_ORDER_SQUARE) :: R
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS)            :: v
	real(kind=GRID_SR),dimension(_SWE_PATCH_ORDER_SQUARE) :: vn
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS)            :: vm	                   
	integer :: i
                   
	R = 0.0_GRID_SR
	vn = 1.0_GRID_SR
	vm = 1.0_GRID_SR
	v = vm - matmul(mue_inv,vn)
	
	do i = 1,_SWE_DG_DOFS
	   R(i,1) = v(i)
	end do
	
	mue_inv_hat = mue_inv+R
end subroutine


subroutine init_basis_der_x_hat()
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS,_SWE_DG_DOFS) :: R
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS) :: v
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS)            :: vn
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS) :: vm	                   
	integer :: i
                   
	R = 0.0_GRID_SR
	vn = 1.0_GRID_SR
	vm = 1.0_GRID_SR
	v = matmul(basis_der_x,vn)
	
	do i = 1,_SWE_DG_DOFS
	   R(i,i) = v(i)
	end do
	
	basis_der_x_hat = basis_der_x - R
end subroutine


subroutine init_basis_der_y_hat()
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS,_SWE_DG_DOFS) :: R
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS) :: v
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS)            :: vn
	real(kind=GRID_SR),dimension(_SWE_DG_DOFS) :: vm	                   
	integer :: i
                   
	R = 0.0_GRID_SR
	vn = 1.0_GRID_SR
	vm = 1.0_GRID_SR
	v = matmul(basis_der_y,vn)
	
	do i = 1,_SWE_DG_DOFS
	   R(i,i) = v(i)
	end do
	
	basis_der_y_hat = basis_der_y - R
end subroutine

subroutine init_t_k_t_11_inv_x_t_k_t_10_hat()
	real(kind=GRID_SR),dimension(_SWE_DG_ORDER+1,1) :: R
	real(kind=GRID_SR),dimension(1) :: v

	v = 1.0_GRID_SR
!	R = matmul(t_k_t_11_inv_x_t_k_t_10,v)

!	t_k_t_11_inv_x_t_k_t_10_hat(1,1) = t_k_t_11_inv_x_t_k_t_10(1,1) - R(1,1)
	
end subroutine

subroutine init_norm_to_edge_type()
			norm_to_edge_type = 0.0_GRID_SR
			norm_to_edge_type(8, 2, 0) = 1
			norm_to_edge_type(8, 1, 1) = 2
			norm_to_edge_type(8, 0, 2) = 3
			norm_to_edge_type(8, 0,-2) = 3 
			norm_to_edge_type(8,-1,-1) = 2
			norm_to_edge_type(8,-2, 0) = 1

			norm_to_edge_type(7, 2, 0) = 2
			norm_to_edge_type(7, 1, 1) = 3			
			norm_to_edge_type(7, 1,-1) = 1
			norm_to_edge_type(7,-1, 1) = 1
			norm_to_edge_type(7,-1,-1) = 3			
			norm_to_edge_type(7,-2, 0) = 2

	
			norm_to_edge_type(6, 2, 0) = 3
			norm_to_edge_type(6, 1,-1) = 2
			norm_to_edge_type(6, 0, 2) = 1
			norm_to_edge_type(6, 0,-2) = 1
			norm_to_edge_type(6,-1, 1) = 2
			norm_to_edge_type(6,-2, 0) = 3

			norm_to_edge_type(5, 1, 1) = 1			
			norm_to_edge_type(5, 1,-1) = 3
			norm_to_edge_type(5, 0, 2) = 2
			norm_to_edge_type(5, 0,-2) = 2
			norm_to_edge_type(5,-1, 1) = 3
			norm_to_edge_type(5,-1,-1) = 1


			norm_to_edge_type(4, 2, 0) = 1
			norm_to_edge_type(4, 1, 1) = 2	
			norm_to_edge_type(4, 0, 2) = 3
			norm_to_edge_type(4, 0,-2) = 3
			norm_to_edge_type(4,-1,-1) = 2 
			norm_to_edge_type(4,-2, 0) = 1

			norm_to_edge_type(3, 1, 1) = 3			
			norm_to_edge_type(3, 1,-1) = 1
			norm_to_edge_type(3, 2, 0) = 2
			norm_to_edge_type(3,-2, 0) = 2
			norm_to_edge_type(3,-1, 1) = 1
			norm_to_edge_type(3,-1,-1) = 3


			norm_to_edge_type(2, 2, 0) = 3
			norm_to_edge_type(2, 1,-1) = 2
			norm_to_edge_type(2, 0, 2) = 1						
			norm_to_edge_type(2, 0,-2) = 1
			norm_to_edge_type(2,-1, 1) = 2 
			norm_to_edge_type(2,-2, 0) = 3

			norm_to_edge_type(1, 1, 1) = 1
			norm_to_edge_type(1, 1,-1) = 3
			norm_to_edge_type(1, 0, 2) = 2
			norm_to_edge_type(1, 0,-2) = 2
			norm_to_edge_type(1,-1, 1) = 3
			norm_to_edge_type(1,-1,-1) = 1


!			print*,ref_plotter_data			
end subroutine			

subroutine init_projection()
			integer :: i,j,edge_type,indx,edge

			idx_project_DG = 0
			do j = 1,3
				 edge_type =  j
				 do i = 1,_SWE_DG_ORDER+1
						select case(edge_type)
				    case(1)							!right
							 idx_project_DG(j,i) = _SWE_DG_DOFS-(i+1)*(i)/2 +1
						case(2)							!mid
							 idx_project_DG(j,i) = _SWE_DG_DOFS-(_SWE_DG_ORDER-i+2)*(_SWE_DG_ORDER-i+1)/2
						case(3)							!left
							 idx_project_DG(j,i) = i
						case default
							 stop
						end select
				 end do
			end do

			idx_project_FV = 0.0_GRID_SR
			
			do edge = 1,3
				 select case (edge)       
				 case (3)								!cells with id i*i+1 (left leg)
						do i=0, _SWE_PATCH_ORDER - 1
							 j=_SWE_PATCH_ORDER-1-i
							 idx_project_FV(edge,i+1) = j*j + 1
						end do
				 case (2)								! hypotenuse
						do i=1, _SWE_PATCH_ORDER
							 j=_SWE_PATCH_ORDER+1-i
							 idx_project_FV(edge,i) = (_SWE_PATCH_ORDER-1)*(_SWE_PATCH_ORDER-1)+2*j-1
						end do
				 case (1)								!cells with id i*i (right leg)
						do i=1, _SWE_PATCH_ORDER
							 idx_project_FV(edge,i) = i*i
						end do
				 end select
			end do

!			project_DG = 0.0_GRID_SR
!
!			do j = 1,3
!				 edge_type =  j
!				 do i = 1,_SWE_DG_ORDER+1
!						select case(edge_type)
!				    case(1)								!right
!							 indx=_SWE_DG_DOFS-(i+1)*(i)/2 +1
!						case(2)							!mid
!							 indx=_SWE_DG_DOFS-(_SWE_DG_ORDER-i+2)*(_SWE_DG_ORDER-i+1)/2
!						case(3)							!left
!							 indx=i
!						case default
!							 stop
!						end select
!						project_DG(edge_type,i,indx) = 1.0_GRID_SR
!				 end do
!			end do
!
!
!			
!			project_FV = 0.0_GRID_SR
!			
!			do edge = 1,3
!				 select case (edge)       
!				 case (3)								!cells with id i*i+1 (left leg)
!						do i=0, _SWE_PATCH_ORDER - 1
!							 j=_SWE_PATCH_ORDER-1-i
!							 project_FV(edge,i+1,j*j + 1) = 1.0_GRID_SR
!						end do
!				 case (2)								! hypotenuse
!						do i=1, _SWE_PATCH_ORDER
!							 j=_SWE_PATCH_ORDER+1-i
!							 project_FV(edge,i,(_SWE_PATCH_ORDER-1)*(_SWE_PATCH_ORDER-1)+2*j-1) = 1.0_GRID_SR
!						end do
!				 case (1)								!cells with id i*i (right leg)
!						do i=1, _SWE_PATCH_ORDER
!							 project_FV(edge,i,i*i) = 1.0_GRID_SR
!						end do
!				 end select
!			end do
			
end subroutine

subroutine lusolve(mat,n,pivot,b)
 integer :: n,ii,i,j,ll
 integer, intent(in) :: pivot(n)

 real(kind=GRID_SR) ::  sum
 real(kind=GRID_SR),intent(inout) ::  b(n)
 real(kind=GRID_SR),intent(in) ::  mat(n,n)

 ii = 0

 do i=1,n
   ll = pivot(i)
   sum = b(ll)
   b(ll) = b(i)
   if(ii.ne.0) then
     do j=ii,i-1
       sum = sum - mat(i,j)*b(j)
     end do ! j loop
   else if(sum.ne.0.0_GRID_SR) then
     ii = i
   end if
   b(i) = sum
 end do ! i loop

 do i=n,1,-1
   sum = b(i)
   if(i < n) then
     do j=i+1,n
       sum = sum - mat(i,j)*b(j)
     end do ! j loop
   end if
   b(i) = sum / mat(i,i)
 end do ! i loop

 return
end subroutine lusolve




END MODULE SWE_dg_matrices
#endif

